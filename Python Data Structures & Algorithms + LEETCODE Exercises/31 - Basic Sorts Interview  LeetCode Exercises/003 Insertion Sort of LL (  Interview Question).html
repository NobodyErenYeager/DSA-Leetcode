<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "003 Insertion Sort of LL (  Interview Question)", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p><strong>Assignment:</strong></p><p>Write an <code><strong>insertion_sort()</strong></code> method in the <code><strong>LinkedList</strong></code> class that will sort the elements of a linked list in ascending order using the insertion sort algorithm.<br><br>The method should update the <code><strong>head</strong></code> and <code><strong>tail</strong></code> pointers of the linked list to reflect the new order of the nodes in the list.<br><br>You can assume that the input linked list will contain only integers. You should not use any additional data structures to sort the linked list.</p><p><br></p><p><strong>Input:</strong></p><ul><li><p>The <code><strong>LinkedList</strong></code> object containing a linked list with unsorted elements (self).</p></li></ul><p><br></p><p><strong>Output:</strong></p><ul><li><p>None. The method sorts the linked list in place.</p></li></ul><p><br></p><p><strong>Method Description:</strong></p><ul><li><p>If the length of the linked list is less than 2, the method returns and the list is assumed to be already sorted.</p></li><li><p>The first element of the linked list is treated as the sorted part of the list, and the second element is treated as the unsorted part of the list.</p></li><li><p>The first element of the sorted part of the list is then disconnected from the rest of the list, creating a new linked list with only one element.</p></li><li><p>The method then iterates through each remaining node in the unsorted part of the list.</p></li><li><p>For each node in the unsorted part of the list, the method determines its correct position in the sorted part of the list by comparing its value with the values of the other nodes in the sorted part of the list.</p></li><li><p>Once the correct position has been found, the node is inserted into the sorted part of the list at the appropriate position.</p></li><li><p>After all the nodes in the unsorted part of the list have been inserted into the sorted part of the list, the <code><strong>head</strong></code> and <code><strong>tail</strong></code> pointers of the linked list are updated to reflect the new order of the nodes in the list.</p></li></ul><p><br></p><p><strong>Constraints:</strong></p><ul><li><p>The linked list can contain duplicates.</p></li><li><p>The method should be implemented in the <code><strong>LinkedList</strong></code> class.</p></li><li><p>The method should not use any additional data structures to sort the linked list.</p></li></ul><p><br></p><p><br></p>", "tests": [{"file_name": "evaluate.py", "content": "from unittest import TestCase\n\nclass TestLinkedList(TestCase):\n\n    def list_to_values(self, linked_list):\n        values = []\n        current = linked_list.head\n        while current is not None:\n            values.append(current.value)\n            current = current.next\n        return values\n\n    def test_sort_empty_list(self):\n        import exercise\n        ll = exercise.LinkedList(5)\n        ll.head = None\n        ll.tail = None\n        ll.length = 0\n        ll.insertion_sort()\n        self.assertIsNone(ll.head)\n\n    def test_sort_single_element(self):\n        import exercise\n        ll = exercise.LinkedList(5)\n        ll.insertion_sort()\n        self.assertEqual(self.list_to_values(ll), [5])\n\n    def test_sort_already_sorted(self):\n        import exercise\n        ll = exercise.LinkedList(1)\n        ll.append(2)\n        ll.append(3)\n        ll.insertion_sort()\n        self.assertEqual(self.list_to_values(ll), [1, 2, 3])\n\n    def test_sort_reverse_order(self):\n        import exercise\n        ll = exercise.LinkedList(3)\n        ll.append(2)\n        ll.append(1)\n        ll.insertion_sort()\n        self.assertEqual(self.list_to_values(ll), [1, 2, 3])\n\n    def test_sort_random_order(self):\n        import exercise\n        ll = exercise.LinkedList(2)\n        ll.append(1)\n        ll.append(3)\n        ll.insertion_sort()\n        self.assertEqual(self.list_to_values(ll), [1, 2, 3])\n\n    def test_sort_with_duplicates(self):\n        import exercise\n        ll = exercise.LinkedList(3)\n        ll.append(2)\n        ll.append(2)\n        ll.append(1)\n        ll.append(3)\n        ll.insertion_sort()\n        self.assertEqual(self.list_to_values(ll), [1, 2, 2, 3, 3])\n\n"}], "solutions": [{"file_name": "exercise.py", "content": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        \n\nclass LinkedList:\n    def __init__(self, value):\n        new_node = Node(value)\n        self.head = new_node\n        self.tail = new_node\n        self.length = 1\n\n    def print_list(self):\n        temp = self.head\n        while temp is not None:\n            print(temp.value)\n            temp = temp.next\n        \n    def append(self, value):\n        new_node = Node(value)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n        self.length += 1\n\n    def insertion_sort(self):\n        if self.length < 2:\n            return\n        \n        sorted_list_head = self.head\n        unsorted_list_head = self.head.next\n        sorted_list_head.next = None\n        \n        while unsorted_list_head is not None:\n            current = unsorted_list_head\n            unsorted_list_head = unsorted_list_head.next\n            \n            if current.value < sorted_list_head.value:\n                current.next = sorted_list_head\n                sorted_list_head = current\n            else:\n                search_pointer = sorted_list_head\n                while search_pointer.next is not None and current.value > search_pointer.next.value:\n                    search_pointer = search_pointer.next\n                current.next = search_pointer.next\n                search_pointer.next = current\n        \n        self.head = sorted_list_head\n        temp = self.head\n        while temp.next is not None:\n            temp = temp.next\n        self.tail = temp\n        \n        "}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
