<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "006 MinHeap Sink Down", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p>Implement the <code><strong>_sink_down</strong></code> helper method in the <code><strong>MinHeap</strong></code> class. This method is a private helper method that is crucial to maintaining the min heap property when the root element is removed from the heap.<br><br>The class includes a method for initialization, plus helper methods for getting the left child, the right child, and the parent of a node and swapping elements in the heap.<br><br>Here's what your <code><strong>_sink_down</strong></code> method needs to do in detail:</p><ol><li><p>The method takes an index as a parameter. This index is the position of the node in the heap that needs to be 'sunk down' to its appropriate position to maintain the min heap property.</p></li><li><p>In each iteration of its main loop, the method identifies the minimum of the node at the provided index, its left child, and its right child. The indexes of the left and right children can be determined using the <code><strong>_left_child</strong></code> and <code><strong>_right_child</strong></code> methods, respectively.</p></li><li><p>If the minimum value is found to be at the provided index, the method ends. Otherwise, the node at the provided index is swapped with the node with the minimum value. The <code><strong>_swap</strong></code> method can be used for this.</p></li><li><p>The index of the node with the minimum value is then set as the provided index for the next iteration of the loop.</p></li></ol><p><br></p><p>The <code><strong>_sink_down</strong></code> method should aim for an efficient time complexity of O(log n), where n is the number of elements in the heap.<br><br>Consider various edge cases, such as when the node to sink down is already at its correct position, or when it needs to be sunk down multiple levels in the heap. </p><p><br></p><p><br></p>", "tests": [{"file_name": "evaluate.py", "content": "from unittest import TestCase\n\nclass TestMinHeapRemove(TestCase):\n\n    def test_remove_from_empty_heap(self):\n        import exercise\n        min_heap = exercise.MinHeap()\n        self.assertEqual(min_heap.remove(), None)\n\n    def test_remove_single_element(self):\n        import exercise\n        min_heap = exercise.MinHeap()\n        min_heap.insert(5)\n        self.assertEqual(min_heap.remove(), 5)\n        self.assertEqual(min_heap.heap, [])\n\n    def test_remove_multiple_elements(self):\n        import exercise\n        min_heap = exercise.MinHeap()\n        values = [5, 10, 3, 20, 1]\n        for value in values:\n            min_heap.insert(value)\n        self.assertEqual(min_heap.remove(), 1)\n        self.assertEqual(min_heap.heap, [3, 10, 5, 20])\n\n    def test_remove_maintains_heap_property(self):\n        import exercise\n        min_heap = exercise.MinHeap()\n        values = [5, 12, 3, 11, 9, 6]\n        for value in values:\n            min_heap.insert(value)\n        min_heap.remove()\n        \n        self.assertTrue(all(min_heap.heap[i] <= min_heap.heap[min_heap._left_child(i)] \n                            if min_heap._left_child(i) < len(min_heap.heap) else True \n                            for i in range(len(min_heap.heap))))\n        \n        self.assertTrue(all(min_heap.heap[i] <= min_heap.heap[min_heap._right_child(i)] \n                            if min_heap._right_child(i) < len(min_heap.heap) else True \n                            for i in range(len(min_heap.heap))))\n\n\n    def test_remove_negative_values(self):\n        import exercise\n        min_heap = exercise.MinHeap()\n        values = [-5, -10, -15]\n        for value in values:\n            min_heap.insert(value)\n        self.assertEqual(min_heap.remove(), -15)\n        self.assertEqual(min_heap.heap, [-10, -5])\n"}], "solutions": [{"file_name": "exercise.py", "content": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def _left_child(self, index):\n        return 2 * index + 1\n\n    def _right_child(self, index):\n        return 2 * index + 2\n\n    def _parent(self, index):\n        return (index - 1) // 2\n\n    def _swap(self, index1, index2):\n        self.heap[index1], self.heap[index2] = self.heap[index2], self.heap[index1]\n\n    def insert(self, value):\n        self.heap.append(value)\n        current = len(self.heap) - 1\n\n        while current > 0 and self.heap[current] < self.heap[self._parent(current)]:\n            self._swap(current, self._parent(current))\n            current = self._parent(current)\n\n    def _sink_down(self, index):\n        min_index = index\n        while True:\n            left_index = self._left_child(index)\n            right_index = self._right_child(index)\n\n            if (left_index < len(self.heap) and \n                    self.heap[left_index] < self.heap[min_index]):\n                min_index = left_index\n\n            if (right_index < len(self.heap) and \n                    self.heap[right_index] < self.heap[min_index]):\n                min_index = right_index\n\n            if min_index != index:\n                self._swap(index, min_index)\n                index = min_index\n            else:\n                return\n\n    def remove(self):\n        if len(self.heap) == 0:\n            return None\n\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        min_value = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._sink_down(0)\n\n        return min_value\n"}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
