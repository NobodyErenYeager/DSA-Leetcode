<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "004 rBST Delete", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p>Write two Python functions for the BinarySearchTree class: <code><strong>delete_node</strong></code> and <code><strong>__delete_node</strong></code>. <br><br>These functions should work together to delete a node with a given integer value from the binary search tree while maintaining its structure and ordering after deletion.</p><ol><li><p><code><strong>delete_node(value)</strong></code>: This function should take an integer value as input and call the <code><strong>__delete_node</strong></code> function with the root node of the binary search tree and the input value. It should then update the root of the binary search tree with the returned value from the <code><strong>__delete_node</strong></code> function.</p></li><li><p><code><strong>__delete_node(current_node, value)</strong></code>: This function should take a Node object (current_node) and an integer value as input. It should be a recursive helper function that facilitates the node deletion process for the <code><strong>delete_node</strong></code> function. The function should have the following behavior:</p><ul><li><p>If the current_node is None, return None.</p></li><li><p>If the input value is smaller than the value of the current_node, set the left child of the current_node to the result of calling <code><strong>__delete_node</strong></code> with the left child of the current_node and the input value.</p></li><li><p>If the input value is larger than the value of the current_node, set the right child of the current_node to the result of calling <code><strong>__delete_node</strong></code> with the right child of the current_node and the input value.</p></li><li><p>If the input value is equal to the value of the current_node, perform the deletion according to the following cases:</p><ul><li><p>If the current_node has no children, return None.</p></li><li><p>If the current_node has only a left child, return the left child.</p></li><li><p>If the current_node has only a right child, return the right child.</p></li><li><p>If the current_node has both left and right children, find the minimum value in the right subtree of the current_node, replace the value of the current_node with the found minimum value, and then delete the node with the minimum value in the right subtree using a recursive call to <code><strong>__delete_node</strong></code>.</p></li></ul></li><li><p>Return the current_node after making the necessary updates.</p></li></ul></li></ol><p>Your implementation should ensure that the binary search tree maintains its structure and ordering after the deletion operation.</p><p><br></p><p>Please click on \"Hints\" (above) to see the pseudo-code.</p>", "tests": [{"file_name": "evaluate.py", "content": "from unittest import TestCase\n\nimport unittest\n\nclass TestBinarySearchTree(unittest.TestCase):\n    \n    def test_delete_node_no_children(self):\n        import exercise\n        bst = exercise.BinarySearchTree()\n        values = [5, 3, 8]\n        for v in values:\n            bst.r_insert(v)\n            \n        bst.delete_node(3)\n        self.assertEqual(bst.root.left, None)\n        \n    def test_delete_node_only_left_child(self):\n        import exercise\n        bst = exercise.BinarySearchTree()\n        values = [5, 3, 8, 1]\n        for v in values:\n            bst.r_insert(v)\n            \n        bst.delete_node(3)\n        self.assertEqual(bst.root.left.value, 1)\n        \n    def test_delete_node_only_right_child(self):\n        import exercise\n        bst = exercise.BinarySearchTree()\n        values = [5, 3, 8, 9]\n        for v in values:\n            bst.r_insert(v)\n            \n        bst.delete_node(8)\n        self.assertEqual(bst.root.right.value, 9)\n        \n    def test_delete_node_two_children(self):\n        import exercise\n        bst = exercise.BinarySearchTree()\n        values = [5, 3, 8, 1, 4, 7, 9]\n        for v in values:\n            bst.r_insert(v)\n            \n        bst.delete_node(3)\n        self.assertEqual(bst.root.left.value, 4)\n        \n    def test_delete_root(self):\n        import exercise\n        bst = exercise.BinarySearchTree()\n        values = [5, 3, 8]\n        for v in values:\n            bst.r_insert(v)\n            \n        bst.delete_node(5)\n        self.assertEqual(bst.root.value, 8)\n\n    def test_delete_non_existent_node(self):\n        import exercise\n        bst = exercise.BinarySearchTree()\n        values = [5, 3, 8]\n        for v in values:\n            bst.r_insert(v)\n        \n        # Attempt to delete a node with value 10 (which doesn't exist in the tree).\n        # This shouldn't change the structure of the tree.\n        original_root_value = bst.root.value\n        bst.delete_node(10)\n        self.assertEqual(bst.root.value, original_root_value)"}], "solutions": [{"file_name": "exercise.py", "content": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        \n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n          \n    def __r_insert(self, current_node, value):\n        if current_node == None: \n            return Node(value)   \n        if value < current_node.value:\n            current_node.left = self.__r_insert(current_node.left, value)\n        if value > current_node.value:\n            current_node.right = self.__r_insert(current_node.right, value) \n        return current_node    \n\n    def r_insert(self, value):\n        if self.root == None: \n            self.root = Node(value)\n        self.__r_insert(self.root, value)  \n\n\n    def min_value(self, current_node):\n        while (current_node.left is not None):\n            current_node = current_node.left\n        return current_node.value \n\n    def __delete_node(self, current_node, value):\n\t    if current_node == None: \n\t\t    return None\n\t    if value < current_node.value:\n\t\t    current_node.left = self.__delete_node(current_node.left, value)\n\t    elif value > current_node.value: \n\t\t    current_node.right = self.__delete_node(current_node.right, value)\n\t    else:\n\t\t    if current_node.left == None and current_node.right == None:\n\t\t\t    return None\n\t\t    elif current_node.left == None:\n\t\t\t    current_node = current_node.right\n\t\t    elif current_node.right == None:\n\t\t\t    current_node = current_node.left\n\t\t    else:\n\t\t\t    sub_tree_min = self.min_value(current_node.right)\n\t\t\t    current_node.value = sub_tree_min\n\t\t\t    current_node.right = self.__delete_node(current_node.right, sub_tree_min)\n\t    return current_node\n    \n    def delete_node(self, value):\n        self.root = self.__delete_node(self.root, value)\n\n\n\n\n##########################################################   \n##   Test code below will print output to \"User logs\"   ##\n##########################################################\n\ndef check(expect, actual, message):\n    print(message)\n    print(\"EXPECTED:\", expect)\n    print(\"RETURNED:\", actual)\n    print(\"PASS\" if expect == actual else \"FAIL\", \"\\n\")\n\n\n# test_delete_node_no_children\nprint(\"\\n----- Test: Delete node with no children -----\\n\")\nbst = BinarySearchTree()\nvalues = [5, 3, 8]\nfor v in values:\n    print(\"Inserting value:\", v)\n    bst.r_insert(v)\nbst.delete_node(3)\ncheck(None, bst.root.left, \"Left child of root after deleting 3:\")\n\n\n# test_delete_node_only_left_child\nprint(\"\\n----- Test: Delete node with only left child -----\\n\")\nbst = BinarySearchTree()\nvalues = [5, 3, 8, 1]\nfor v in values:\n    print(\"Inserting value:\", v)\n    bst.r_insert(v)\nbst.delete_node(3)\ncheck(1, bst.root.left.value, \"Left child of root after deleting 3:\")\n\n\n# test_delete_node_only_right_child\nprint(\"\\n----- Test: Delete node with only right child -----\\n\")\nbst = BinarySearchTree()\nvalues = [5, 3, 8, 9]\nfor v in values:\n    print(\"Inserting value:\", v)\n    bst.r_insert(v)\nbst.delete_node(8)\ncheck(9, bst.root.right.value, \"Right child of root after deleting 8:\")\n\n\n# test_delete_node_two_children\nprint(\"\\n----- Test: Delete node with two children -----\\n\")\nbst = BinarySearchTree()\nvalues = [5, 3, 8, 1, 4, 7, 9]\nfor v in values:\n    print(\"Inserting value:\", v)\n    bst.r_insert(v)\nbst.delete_node(3)\ncheck(4, bst.root.left.value, \"Left child of root after deleting 3:\")\n\n\n# test_delete_root\nprint(\"\\n----- Test: Delete root -----\\n\")\nbst = BinarySearchTree()\nvalues = [5, 3, 8]\nfor v in values:\n    print(\"Inserting value:\", v)\n    bst.r_insert(v)\nbst.delete_node(5)\ncheck(8, bst.root.value, \"Root value after deleting 5:\")\n\n\n# test_delete_non_existent_node\nprint(\"\\n----- Test: Attempt to delete a non-existent node -----\\n\")\nbst = BinarySearchTree()\nvalues = [5, 3, 8]\nfor v in values:\n    print(\"Inserting value:\", v)\n    bst.r_insert(v)\noriginal_root_value = bst.root.value\nbst.delete_node(10)\ncheck(original_root_value, bst.root.value, \"Root value after attempting to delete 10:\")\n"}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
